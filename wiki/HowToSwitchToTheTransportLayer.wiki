#summary How to switch the transport layer from TCP to distributed Erlang

= Introduction =

Scalaris supports two mechanism for exchanging information/messages between the nodes:
  # custom TCP protocol
  # distributed Erlang
In the default configuration the former is used and its implementation is in src/comm_layer. The latter uses the Erlang native mechanism for sending messages between nodes.

= Steps =

  * change the transport layer in the code. in include/scalaris.hrl change
  {{{
  -define(TCP_LAYER, true).
  %-define(BUILTIN, true).
  }}}
  to
  {{{
  %-define(TCP_LAYER, true).
  -define(BUILTIN, true).
  }}}
  * change the location of the boot server and known hosts in bin/scalaris.cfg or bin/scalaris.local.cfg. For the TCP-layer the configuration could look as follows:
  {{{
  {boot_host, {{127,0,0,1},14195,boot}}.
  {known_hosts, [{{127,0,0,1},14195, service_per_vm}, {{127,0,0,1},14196, service_per_vm},
                 {{127,0,0,1},14197, service_per_vm}, {{127,0,0,1},14198, service_per_vm}]}.

  }}}
  For the distributed Erlang mode you have to configure the location using standard Erlang pids:
  {{{
  {boot_host, {boot,'boot@foo.bar.com'}}.
  {known_hosts, [{service_per_vm,'boot@foo.bar.com'},
                 {service_per_vm,'node@foo.bar.com'},
                 {service_per_vm,'node2@foo.bar.com'},
                 {service_per_vm,'node3@foo.bar.com'}]}.
  }}}
  where foo.bar.com is the hostname of the boot server.
  * make the names of the Erlang VMs globally accessible. You have to use "-name" in boot.sh, cs_local.sh, cs_local2.sh.  