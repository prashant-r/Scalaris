#summary How to access Scalaris from Erlang.

= Introduction =

In the following, we describe how to access Scalaris from your application servers, where the application servers are written in Erlang and are running in their own VMs.

For the original discussion see:
http://groups.google.com/group/scalaris/browse_thread/thread/c63366216465e38

The problem in this setup is Scalaris' transaction API. We use anonymous functions to describe the sequence of calls which should be executed in a transaction. However, anonymous functions in Erlang cannot be sent around in messages. So the module containing the code has to be made available in the Scalaris nodes.

= Details =

Move all code accessing Scalaris into separate modules. It is good practice to separate the code accessing the database from the rest anyway. 

In the following, you have a small fragment of an employee database hosted in Scalaris:
{{{
-module(employee_db).

-import(transstore.transaction_api, [do_transaction/3, write2/3]).

-export([add_employee/3]).

% @doc adds a new employee to the db
%      returns {success, _} | {fail, Reason}
add_employee(Id, Name, Salary) ->
    TFun = fun(TLog) ->
		   Translog1 = write2(TLog, Id, {employee, Name, Salary}),
		   Translog1
	   end,
    SuccessFun = fun(X) ->
			 {ok, X}
		 end,
    FailureFun = fun(X) ->
			 {fail, X}
		 end,
    do_transaction(TFun, SuccessFun, FailureFun).
}}}

Now, on startup you have to load your code into the Scalaris nodes:
{{{
{Module, Binary, Filename} = code:get_object_code(MyModuleName),
{module, Module} = rpc:call(ScalarisNode, code, load_binary, [Module, Filename, Binary])
}}}

Finally, you can execute your code from the app server:
{{{
Result = rpc:call(ScalarisNode, employee_db, add_employee, [1, "Mike", 5000])
}}}