#summary Frequently asked questions.
#labels Featured

<wiki:toc max_depth="2" />

= General = 

== Is the store persisted on disk? ==

No its not persistent on disk (see also next question). Persistent storage is an often demanded feature, but it is not as easy to do as one might think. Lets explain why:

=== Why persistent storage? ===

==== Persistent storage to overcome node failures and node resets: ====

Scalaris uses quorum algorithms, that assume a crash-stop failure model for
processes. A precondition of such systems is, that a majority of the replicas
of an item is always available.

If this precondition is violated, a majority of the nodes with replicas of an
item x is not available, the item cannot be changed. It is lost. Persistent
storage cannot help directly.

If a minority of the replicas fail, they will be repaired (new replicas are
created on other nodes).

If a single failed node does crash and recover, which is not foreseen in the
crash-stop model, but might happen if we have local persistent storage, we
have
three choices:
  # drop the persistent storage and start as new node (crash-stop model)
  # get some inconsistencies as another node already took over. For a short timeframe there might be more replicas in the system than allowed, which destroys the proper functioning of our majority based algorithms.
  # friendly join the system and update the stored persistent state with the current state in the system (one way to implement that would be (1)).

So, persistent storage does not help in improving the availability or
robustness of the system.

==== Persistent storage to allow pausing the system (controlled shutdown and restart): ====

This would be possible to implement by a snapshot mechanism for
the system. To pause the system, one would cut user access, wait some time for
all ongoing transactions to finish, and then trigger a snapshot to local
disks. On startup, the nodes would continue from the last state after reading
the snapshot. Then user access can be restarted.

==== Persistent storage to have an always up-to-date snapshot of the system: ==== 
Persistence as in traditional replicated databases is not intended by our
system model and thereby not possible. The best alternative would be periodic
snapshots, that can be done also without interrupting the service.

== Can I store more data in Scalaris than ram+swapspace is available in the cluster? ==

Yes. We have several database backends, e.g. src/db_ets.erl (ets) and src/db_toke (tokyocabinet). The former uses the main memory for storing data, while the latter uses tokyocabinet for storing data on disk. With tokycoabinet, only your local disks should limit the total size of your database. Note however, that this still does not provide persistence.

For instructions on switching the database backend to tokyocabinet see [Tokyocabinet].

= Installation =

== Minimum Requirements ==

  * Erlang >= !R13B01 (see [FAQ#Known_Issues Known Issues] below)

=== Optional requirements ===

  * Java-API, CLI: Java >= 5, Ant
  * Storage on disk: Tokycabinet, toke

== Prebuild packages ==

We build rpm and deb packages using checkouts from svn trunk and the latest tagged version and provide them using the openSUSE !BuildService at http://download.opensuse.org/repositories/home:/scalaris/. The available packages are listed in the following table:

|| *Distribution* || *Version* || *Download* ||
|| Fedora || 14 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Fedora_14/] ||
|| Fedora || 15 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Fedora_15/] ||
|| Mandriva || 2009.1 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Mandriva_2009.1/] ||
|| Mandriva || 2010 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Mandriva_2010/] ||
|| Mandriva || 2010.1 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Mandriva_2010.1/] ||
|| openSUSE || 11.3 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_11.3/] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_11.3/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_11.3/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || 11.4 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_11.4/] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_11.4/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_11.4/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || Tumbleweed || Repository: [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Tumbleweed/] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Tumbleweed/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Tumbleweed/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || Factory || Repository: [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Factory/] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Factory/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Factory/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| SLE || 10 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/SLE_10/] <br> [http://download.opensuse.org/repositories/home:/scalaris/SLE_10/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/SLE_10/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| SLE || 11 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/SLE_11/] <br> [http://download.opensuse.org/repositories/home:/scalaris/SLE_11/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/SLE_11/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| SLE || 11 SP1 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/SLE_11_SP1/] <br> [http://download.opensuse.org/repositories/home:/scalaris/SLE_11_SP1/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/scalaris/SLE_11_SP1/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| CentOS || 5.5 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/CentOS_5/] ||
|| RHEL || 5.5 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/RHEL_5/] ||
|| RHEL || 6 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/RHEL_6/] ||
|| Debian || 5.0 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Debian_5.0/] ||
|| Debian || 6.0 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/Debian_6.0/] ||
|| Ubuntu || 9.04 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/xUbuntu_9.04/] ||
|| Ubuntu || 9.10 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/xUbuntu_9.10/] ||
|| Ubuntu || 10.04 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/xUbuntu_10.04/] ||
|| Ubuntu || 10.10 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/xUbuntu_10.10/] ||
|| Ubuntu || 11.04 || Repository: [http://download.opensuse.org/repositories/home:/scalaris/xUbuntu_11.04/] ||

Inside those repositories you will also find erlang packages - you don't need these if you already have a recent enough erlang version - the package dependencies are set accordingly.

=== How to add deb-based repositories (Debian, Ubuntu)? ===

Please note that the openSUSE !BuildService does not create a source repository for .deb-based distributions. To add one of our repositories to your System, add a line like the following to your sources.list (probably in `/etc/apt/`):

{{{
deb http://download.opensuse.org/repositories/home:/scalaris/xUbuntu_11.04/ ./
}}}

Then download our package signing key and add it to your system (as root):

{{{
wget http://download.opensuse.org/repositories/home:/scalaris/openSUSE_Factory/repodata/repomd.xml.key
apt-key add repomd.xml.key
}}}

Afterwards, installing our Scalaris packages should be possible as usually, e.g. by calling
{{{
apt-get update
apt-get install scalaris
}}}

Refer to http://en.opensuse.org/openSUSE:Build_Service_Debian_builds#Configuring_sources.list if you are having trouble adding .deb-based repositories.

== How to build an rpm? ==

{{{
svn checkout http://scalaris.googlecode.com/svn/trunk/ scalaris-0.0.1
tar -cvzf scalaris-0.0.1.tar.gz scalaris-0.0.1 --exclude-vcs
cp scalaris-0.0.1.tar.gz /usr/src/packages/SOURCES/
rpmbuild -ba scalaris-0.0.1/contrib/packages/scalaris.spec
}}}
Your source and binary rpm will be generated in /usr/src/packages/SRPMS and RPMS. Note however that this rpm's version will be 0.0.1, contrary to the packages in the repositories mentioned above. Different versions can be set in the given `.spec` file

== Does Scalaris run on Windows? ==

No. Well, maybe.

  # install Erlang (http://www.erlang.org/download.html)
  # install OpenSSL (for crypto module) (http://www.slproweb.com/products/Win32OpenSSL.html)
  # checkout Scalaris code from SVN
  # adapt the path to your Erlang installation in build.bat
  # start a `cmd.exe`
  # go to the Scalaris directory
  # run `build.bat` in the cmd window
  # check that there were no errors during the compilation; warnings are fine
  # go to the `bin` sub-directory
  # adapt the path to your Erlang installation in `firstnode.bat`, and `joining_node.bat`
  # run `firstnode.bat` in the cmd window

If you have Erlang < !R13B04, you will need to adapt the `Emakefile` that `build.bat` generates if it doesn't exist.
Replace every occurrence of
{{{
, {d, tid_not_builtin} 
}}}
with these lines (note the first ","!) and try to compile again, using build.bat. It should work now.
{{{
, {d, type_forward_declarations_are_not_allowed}, {d, forward_or_recursive_types_are_not_allowed}
}}}

Note: we do not support Scalaris on Windows at the moment.


= Configuration =

== How can I change the web server port/yaws port? ==

For changing the yaws port of the first node or a normal node change the `YAWSPORT` variable in its start script, e.g. `bin/firstnode.sh` or `bin/joining_node.sh`.

= Usage =

== What is the difference between a management-server and an ordinary node? ==

Scalaris nodes can take two roles:
  * a management-server and
  * a Scalaris node.

As a management-server a Scalaris node maintains a list of all Scalaris nodes in the system and provides a web-interface for debugging - including different plots of the ring. It has no administrative tasks. A ring could be created without one.

Note that `./bin/firstnode.sh` starts an Erlang VM with both, a management-server and a Scalaris node which is marked as the _first_ node.

== Why is one Scalaris node marked as _first_? ==

When starting a Scalaris ring we have to mark exactly one node as the first node. This node will not try contacting any other node and simply wait for connections. It thus creates a new ring.

We are currently using a command line parameter `-scalaris first true` to mark the first Scalaris node inside an Erlang VM as being the first (see `bin/scalarisctl` and `dht_node:init/1`).

For a fault-tolerant setup, Scalaris is able to select the first node by itself from the list of known_hosts. Scalaris will then start, if a majority of the known hosts becomes available (See -q in `bin/scalarisctl`). In this setup no node has to be marked first explicitly.

== How do I start a ring? ==

{{{
./bin/firstnode.sh`
}}}

starts both a boot server and a Scalaris node - a ring of size 1.
Further clients can be started using
{{{
./bin/joining_node.sh
./bin/joining_node.sh 2
./bin/joining_node.sh 3
}}}

Alternatively, `scalarisctl -m start` starts a management-server and `scalarisctl -s start` starts a node similar to `joining_node.sh`. A Scalaris node can be marked as first using the parameter `-f`. To start Scalaris in the background, use `-d`. Refer to the help `scalarisctl -h` for further options.

== How do I delete a key? ==

The principle issues with deleting keys from Scalaris are described in 
[http://groups.google.com/group/scalaris/browse_thread/thread/ff1d9237e218799 this] thread of the mailing list.

In short: deleting a key may violate one of Scalaris' fundamental assumptions - version numbers of keys never decrease. Everything is fine, as long as all replicas are deleted. If some remain, because a node was not available during the delete, you may get into trouble.

Keys can be deleted outside transactions from Erlang and Java.

In Erlang you call api_rdht:delete(Key) which returns 
{ok, pos_integer(), list()} | {fail, timeout} | 
{fail, timeout, pos_integer(), list()} | {fail, node_not_found}).
The pos_integer() indicates how many replicas were successfully deleted, and the list contains further details.

In Java you can call delete(key) or delete(key, timeout) from the Scalaris object and get further details on the result by calling getLastDeleteResult(). 


== What does the "discarded messages" error message mean? ==

If you stop a Scalaris node and immediately restart it, you can get messages like the following:
{{{
[error] Discarding message {ping,{{127,0,0,1},14195,<9148.128.0>}} from <0.108.0> to <0.102.0> in an old incarnation (3) of this node (1)
}}}
It is not so much an error but a message created by the Erlang runtime that this particular message was sent to the last "incarnation" of this Scalaris node. Here it is the failure detector sending a ping message. After a couple of seconds, the failure detector will notice the change and the messages will stop to appear.

== Java-API ==

=== The Java-client cannot connect to Scalaris. What is wrong? ===

If you do not use our client script (java-api/scalaris) your hostname configuration probably needs some adjustments. Erlang and Java use different mechanisms to determine the full qualified domain name (FQDN), but both have to come to the same result in order to be able to connect.

You may check your installation using:

{{{
scalarisctl checkinstallation
}}}

which will guide you further.

  * For getting the node name Erlang uses, call:
    {{{
    erl -noinput -name boot -eval 'io:format("~s~n", [node()]), halt().'
    }}}
    If this gives you a strange erlang error, replace "boot" in the line above with some arbitrary name.
  * For getting the hostname the Java-API uses, call:
    * installed with an RPM:
      {{{
      scalaris --noerl -lh
      }}}
    * inside the source directory:
      {{{
      ./java-api/scalaris --noconfig --noerl -lh
      }}}

The domain name from Erlang should be the same as the name printed by the Java client. If not, you may need to change your `/etc/hosts` or `/etc/hostname` for it to work.

== Python-API ==

=== Reading a list of (small) integers results in a unicode object instead of a list. ===

Unfortunately, Erlang can not distinguish between list of (small) integers and strings (which are lists of small integers, internally). Therefore, we can not guess the resulting type neither in the Java API, nor in the Python API.
The Java API contains several ???Value() methods for the values read back from 
Scalaris.
Since python is dynamically typed, most of these are not needed except for the 
conversion from (falsely interpreted) strings to lists of integers. Use our `str_to_list()` utility method form the `Scalaris` module for this task.

Note: You can safely use `Scalaris.str_to_list()` for any integer list (even those with large integers which are already returned as valid lists). It will return the original value if it is not a string or unicode object.

= Known Issues =

== Publishing topics with Erlang !R13B01 may fail ==

The httpc_handler module of the !R13B01 distribution sporadically crashes when a message is published to a web server. This can be seen using our integrated java tests. There have been some changes to that module in !R13B02 which seem to have fixed this bug. We haven't observed this behavior in Erlang !R13B02 - R14A.

== Configure claims that the Java client script may not work ==

Our client script wrapper in `java-api/scalaris` uses `java-functions` and `build-classpath` to cope with distribution-specific paths. If either of them is not present, the client script _may_ not work. The following explains a bit more what they do and how they are used:

  * `java-functions` (if present) will be used to setup the java environment before starting the client
  * `build-classpath` is a script that eases classpath creation especially when a script is being used on different platforms. If `build-classpath` is not present, our wrapper script will try to locate dependent jar files in `$SCALARIS_JAVA_HOME/lib` - these jars include `OtpErlang-1.5.4.jar` and `jakarta-commons-cli-1.2.jar` which can be copied from `./java-api/lib/`. If unset, SCALARIS_JAVA_HOME will be set to the client wrapper script's location which enables the script to be called from a checkout of the scalaris sources.