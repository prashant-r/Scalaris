#summary Frequently asked questions.
#labels Featured

<wiki:toc max_depth="2" />

= General = 

== Is the store persisted on disk? ==

No its not persistent on disk (see also next question). Persistent storage is an often demanded feature, but it is not as easy to do as one might think. Lets explain why:

=== Why persistent storage? ===

==== Persistent storage to overcome node failures and node resets: ====

Scalaris uses quorum algorithms, that assume a crash-stop failure model for
processes. A precondition of such systems is, that a majority of the replicas
of an item is always available.

If this precondition is violated, a majority of the nodes with replicas of an
item x is not available, the item cannot be changed. It is lost. Persistent
storage cannot help directly.

If a minority of the replicas fail, they will be repaired (new replicas are
created on other nodes).

If a single failed node does crash and recover, which is not foreseen in the
crash-stop model, but might happen if we have local persistent storage, we
have
three choices:
  # drop the persistent storage and start as new node (crash-stop model)
  # get some inconsistencies as another node already took over. For a short timeframe there might be more replicas in the system than allowed, which destroys the proper functioning of our majority based algorithms.
  # friendly join the system and update the stored peristent state with the current state in the system (one way to implement that would be (1)).

So, persistent storage does not help in improving the availability or
robustness of the system.

==== Persistent storage to allow pausing the system (controlled shutdown and restart): ====

This would be possible to implement by a snapshot mechanism for
the system. To pause the system, one would cut user access, wait some time for
all ongoing transactions to finish, and then trigger a snapshot to local
disks. On startup, the nodes would continue from the last state after reading
the snapshot. Then user access can be restarted.

==== Persistent storage to have an always up-to-date snapshot of the system: ==== 
Persistency as in traditional replicated databases is not intended by our
system model and thereby not possible. The best alternative would be periodic
snapshots, that can be done also without interrupting the service.

== Can I store more data in Scalaris than ram+swapspace is available in the cluster? ==

Yes. We have several database backends, e.g. src/db_ets.erl (ets) and src/db_toke (tokyocabinet). The former uses the main memory for storing data, while the latter uses tokyocabinet for storing data on disk. With tokycoabinet, only your local disks should limit the total size of your database. Note however, that this still does not provide persistency.

For instructions on switching the database backend to tokyocabinet see [Tokyocabinet].

= Installation =

== Minimum Requirements ==

  * Erlang >= !R13B01 (see [FAQ#Known_Issues Known Issues] below)

=== Optional requirements ===

  * Java-API, CLI: Java >= 5, Ant
  * Storage on disk: Tokycabinet, toke

== Prebuild packages ==

We build rpm and deb packages using checkouts from svn trunk and the latest tagged version and provide them using the openSUSE !BuildService at http://download.opensuse.org/repositories/home:/tschuett/. The available packages are listed in the following table:

|| *Distribution* || *Version* || *Download* ||
|| Fedora || 9 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Fedora_9/] ||
|| Fedora || 10 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Fedora_10/] ||
|| Fedora || 11 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Fedora_11/] ||
|| Fedora || 12 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Fedora_12/] ||
|| Fedora || 13 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Fedora_13/] ||
|| Mandriva || 2008 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Mandriva_2008/] ||
|| Mandriva || 2009 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Mandriva_2009/] ||
|| Mandriva || 2009.1 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Mandriva_2009.1/] ||
|| Mandriva || 2010 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Mandriva_2010/] ||
|| Mandriva || 2010.1 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Mandriva_2010.1/] ||
|| openSUSE || 11.0 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.0/] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.0/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.0/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || 11.1 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.1/] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.1/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.1/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || 11.2 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.2/] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.2/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.2/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || 11.3 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.3/] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.3/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_11.3/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| openSUSE || Factory || Repository: [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_Factory/] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_Factory/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/openSUSE_Factory/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| SLE || 10 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/SLE_10/] <br> [http://download.opensuse.org/repositories/home:/tschuett/SLE_10/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/SLE_10/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| SLE || 11 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/SLE_11/] <br> [http://download.opensuse.org/repositories/home:/tschuett/SLE_11/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/SLE_11/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| SLE || 11 SP1 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/SLE_11_SP1/] <br> [http://download.opensuse.org/repositories/home:/tschuett/SLE_11_SP1/scalaris.ymp 1-Click Install (stable)] <br> [http://download.opensuse.org/repositories/home:/tschuett/SLE_11_SP1/scalaris-svn.ymp 1-Click Install (unstable)] ||
|| CentOS || 5.5 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/CentOS_5/] ||
|| RHEL || 5.5 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/RHEL_5/] ||
|| Debian || 5.0 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/Debian_5.0/] ||
|| Ubuntu || 9.04 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/xUbuntu_9.04/] ||
|| Ubuntu || 9.10 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/xUbuntu_9.10/] ||
|| Ubuntu || 10.04 || Repository: [http://download.opensuse.org/repositories/home:/tschuett/xUbuntu_10.04/] ||

Inside those repositories you will also find erlang packages - you don't need these if you already have a recent enough erlang version - the package dependencies are set accordingly.

=== How to add deb-based repositories (Debian, Ubuntu)? ===

Please note that the openSUSE !BuildService does not create a source repository for .deb-based distributions. To add one of our repositories to your System, add a line like the following to your sources.list:

{{{
deb http://download.opensuse.org/repositories/home:/tschuett/xUbuntu_10.04/ ./
}}}

Refer to http://en.opensuse.org/openSUSE:Build_Service_Debian_builds#Configuring_sources.list if you are having trouble adding .deb-based repositories.

== How to build an rpm? ==

{{{
svn checkout http://scalaris.googlecode.com/svn/trunk/ scalaris-0.0.1
tar -cvzf scalaris-0.0.1.tar.gz scalaris-0.0.1 --exclude-vcs
cp scalaris-0.0.1.tar.gz /usr/src/packages/SOURCES/
rpmbuild -ba scalaris-0.0.1/contrib/packages/scalaris.spec
}}}
Your source and binary rpm will be generated in /usr/src/packages/SRPMS and RPMS. Note however that this rpm's version will be 0.0.1, contrary to the packages in the repositories mentioned above. Different versions can be set in the given `.spec` file

== Does Scalaris run on Windows? ==

No. Well, maybe.

  # install Erlang (http://www.erlang.org/download.html)
  # install OpenSSL (for crypto module) (http://www.slproweb.com/products/Win32OpenSSL.html)
  # checkout Scalaris code from SVN
  # adapt the path to your Erlang installation in build.bat
  # start a `cmd.exe`
  # go to the Scalaris directory
  # run `build.bat` in the cmd window
  # check that there were no errors during the compilation; warnings are fine
  # go to the `bin` sub-directory
  # adapt the path to your Erlang installation in `boot.bat`, `cs_local.bat`, `cs_local2.bat` and `cs_local3.bat`
  # run `boot.bat` in the cmd window

If you have Erlang < !R13B04, you will need to adapt the `Emakefile` that `build.bat` generates if it doesn't find one. There will be empty lines in the first three blocks ending with " ]}." - add the following to these lines (note the first ","!) and try to compile again, using build.bat. It should work now.
{{{
, {d, type_forward_declarations_are_not_allowed}, {d, forward_or_recursive_types_are_not_allowed}
}}}

Note: we do not support Scalaris on Windows at the moment.


= Configuration =

== How can I change the web server port/yaws port? ==

For changing the yaws port of the boot server or a normal node change the `YAWSPORT` variable in its start script, e.g. `bin/boot.sh` or `bin/cs_local?.sh`.

== The Java-client cannot connect to Scalaris. What is wrong? ==

If you do not use our client script (java-api/scalaris) your hostname configuration probably needs some adjustments. Erlang and Java use different mechanisms to determine the full qualified domain name (FQDN), but both have to come to the same result in order to be able to connect.

You may check your installation using:

{{{
scalarisctl checkinstallation
}}}

which will guide you further.

  * For getting the node name Erlang uses, call:
    {{{
    erl -noinput -name boot -eval 'io:format("~s~n", [node()]), halt().'
    }}}
    If this gives you a strange erlang error, replace "boot" in the line above with some arbitrary name.
  * For getting the hostname the Java-API uses, call:
    * installed with an RPM:
      {{{
      scalaris --noerl -lh
      }}}
    * inside the source directory:
      {{{
      ./java-api/scalaris --noconfig --noerl -lh
      }}}

The domain name from Erlang should be the same as the name printed by the Java client. If not, you may need to change your `/etc/hosts` or `/etc/hostname` for it to work.

= Usage =

== What is the difference between a boot server and an ordinary node? ==

Scalaris has two types of nodes:
  * a boot server and
  * a Scalaris node.

Formerly the boot-server was required to add new nodes to the system, hence its name. Today the boot-server only maintains a list of all Scalaris nodes in the system and provides a web-interface for debugging including different plots of the ring. It has no administrative tasks. A ring could be created without one.

Note that for historical reasons `./bin/boot.sh` starts an Erlang VM with both, a boot server and a Scalaris node which is marked as the _first_ node.

== Why is one Scalaris node marked as _first_? ==

When starting a Scalaris ring we have to mark exactly one node as the first node. This node will not try contacting any other node and simply wait for connections. It thus creates a new ring.

We are currently using a command line parameter `-boot_cs first true` (non-empty boot server) / `-scalaris first true` (ordinary Scalaris nodes) to mark the first Scalaris node inside an Erlang VM as being the first (see `bin/scalarisctl` and `dht_node:init/1`).

== How do I start a ring? ==

{{{
./bin/boot.sh`
}}}

starts both a boot server and a Scalaris node - a ring of size 1.
Further clients can be started using
{{{
./bin/cs_local.sh
./bin/cs_local2.sh
./bin/cs_local3.sh
}}}

Alternatively, `scalarisctl boot start` starts a boot server and `scalarisctl node start` starts a client similar to `cs_local.sh`. A boot server without a Scalaris node can be started by providing it with the option `-e` (empty) and a first node can be started with `-f`. To start Scalaris in the background, use `-d`. Refer to the help `scalarisctl -h` for further options.

== How do I delete a key? ==

The principle issues with deleting keys from Scalaris are described in 
[http://groups.google.com/group/scalaris/browse_thread/thread/ff1d9237e218799 this] thread of the mailing list.

In short: deleting a key may violate one of Scalaris' fundamental assumptions - version numbers of keys never decrease. Everything is fine, as long as all replicas are deleted. If some remain, because a node was not available during the delete, you may get into trouble.

Keys can be deleted outside transactions from Erlang and Java.

In Erlang you call transstore.transaction_api:delete(Key, Timeout) which returns 
{ok, pos_integer(), list()} | {fail, timeout} | 
{fail, timeout, pos_integer(), list()} | {fail, node_not_found}).
The pos_integer() indicates how many replicas were successfully deleted, and the list contains further details.

In Java you can call delete(key) or delete(key, timeout) from the Scalaris object and get further details on the result by calling getLastDeleteResult(). 


== What does the "discarded messages" error message mean? ==

If you stop a Scalaris node and immediately restart it, you can get messages like the following:
{{{
[error] Discarding message {ping,{{127,0,0,1},14195,<9148.128.0>}} from <0.108.0> to <0.102.0> in an old incarnation (3) of this node (1)
}}}
It is not so much an error but a message created by the Erlang runtime that this particular message was sent to the last "incarnation" of this Scalaris node. Here it is the failure detector sending a ping message. After a couple of seconds, the failure detector will notice the change and the messages will stop to appear.

= Known Issues =

== Publishing topics with Erlang !R13B01 may fail ==

The httpc_handler module of the !R13B01 distribution sporadically crashes when a message is published to a web server. This can be seen using our integrated java tests. There have been some changes to that module in !R13B02 which seem to have fixed this bug. We haven't observed this behavior in Erlang !R13B02 - !R14A.